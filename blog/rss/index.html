<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Yves Van Goethem's blog]]></title><description><![CDATA[Yves Van Goethem's blog]]></description><link>https://yves.vg/blog/</link><image><url>https://yves.vg/blog/favicon.png</url><title>Yves Van Goethem&apos;s blog</title><link>https://yves.vg/blog/</link></image><generator>Ghost 5.33</generator><lastBuildDate>Wed, 31 Jan 2024 16:53:32 GMT</lastBuildDate><atom:link href="https://yves.vg/blog/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Stop Human Approval in Pull Requests: A case for better collaboration]]></title><description><![CDATA[<p>Your immediate thought might be: &#x201C;This is stupid! Human approval in PRs is a fundamental process in software development, it ensures quality, detects issues, is a great way to collaborate, defines governance, helps to learn from each other&#x2026; aaand everybody does it. It works well for me, I</p>]]></description><link>https://yves.vg/blog/stop-human-approval-in-pull-requests-a-case-for-better-collaboration/</link><guid isPermaLink="false">65ba7666cac0a242ae6c7fff</guid><category><![CDATA[pull requests]]></category><category><![CDATA[collaboration]]></category><category><![CDATA[automation]]></category><category><![CDATA[process]]></category><dc:creator><![CDATA[yvg]]></dc:creator><pubDate>Wed, 31 Jan 2024 16:43:26 GMT</pubDate><content:encoded><![CDATA[<p>Your immediate thought might be: &#x201C;This is stupid! Human approval in PRs is a fundamental process in software development, it ensures quality, detects issues, is a great way to collaborate, defines governance, helps to learn from each other&#x2026; aaand everybody does it. It works well for me, I have countless examples.&#x201D;</p><p>Everybody does it. Some famous people, technical influencers, big corporations,&#x2026; are big proponents of it. And everybody, you, me, and our colleagues who have used PRs are biased by ingrained habits.<br>Some claim that it&apos;s the only way, that PRs should be long-lived and that each keystroke must be reviewed for absolute technical perfection.</p><p>We move from organisation to organisation, from repo to repo, and we repeat the same process over and over again. We don&apos;t question it, we just do it.<br>When it&apos;s not present in small projects, we add it. When an organisation works without it, we introduce it.</p><p>However, <strong>we rarely question this choice.</strong></p><p>So&#x2026; let&apos;s question it, let&apos;s explore some of the consequences that emanate from it, and some alternatives we can apply to yield better results.</p><h2 id="delays">Delays</h2><p>The evident consequence of human approval is delay. While numerous delays can be attributed to it, we can summarise it very simply to one: <strong>delayed value delivery to end customers.</strong> <br>In turn, this results in delayed feedback to enhance our products.</p><p>Many of the same organisations pride themselves in embracing agility and following lean principles. However, if you are familiar with the <strong>8 Wastes of Lean</strong>, waiting for approval is a waste, a waste of time, and a major (if not the biggest) reason for slow delivery, it&apos;s also a waterfall principle right in the middle of the process.</p><p>The immediate consequence of this is visible in metrics. For instance, lead times and delivery frequency visibly improve when human approval is not part of the process.</p><h2 id="quality">Quality</h2><p>Thoroughly reviewing a PR, fully understanding the acceptance criteria, verifying the architecture, reading all files (not just the diff), understanding how it all belongs together, thinking about each variable name, validating interfaces, reading the tests, running the code,&#x2026; is a lot of work.</p><p>And let&apos;s be frank, most people don&apos;t engage in such a comprehensive review. Nobody has the capacity, energy or time for this.<br>Instead, it&apos;s very common to skim through the PR, look for one or two things that one would do differently, and comment on those.</p><p>A more effective way to ensure quality is for people to collaborate, to align beforehand, and to continuously agree on software principles, architectural concepts and design patterns. To write them down and to point to them at every opportunity.</p><p>Bug detection, static analysis, pattern enforcement, test coverage, linting,&#x2026; should be automated as much as possible.</p><h2 id="interpersonal-friction">Interpersonal Friction</h2><p>It&apos;s not uncommon to see heated discussions in PRs, with people getting upset, angry, and frustrated. In the worst cases, people have to be reminded to be respectful and professional by their managers, or worse.</p><p>Still, well-formulated and well-intentioned comments can be misinterpreted.</p><p>By removing human approval, we must shift how we interact with one another. A highly successful way to do so is to <strong>pair</strong>, or at least to <strong>pair code-review</strong>. It&apos;s much easier to have a conversation about code, share ideas, and learn from each other synchronously with a common contextual understanding, rather than trying to express the same context, information and sentiment asynchronously in comments.</p><h2 id="ownership">Ownership</h2><p>When we introduce human approval, we implicitly convey that we don&apos;t trust each other. That others must check our work.</p><p>This tends to diminish accountability. Some authors are less likely to feel responsible for the work they do. While some reviewers will feel more accountable than they should.</p><p>A far healthier approach is to foster <strong>individual responsibility for one&apos;s work.</strong> To let authors decide when and when not to ask for help, when and when not to include feedback, when to pair, and to be fully accountable for the outcome. Not by blaming them when things go wrong, but by helping them to learn from their mistakes.</p><p>It&apos;s a fantastic way to ensure continuous growth, eliminate the fear of merging to production, and become better at what we do, truly collaboratively.</p><h2 id="context-switching">Context Switching</h2><p>This is an obvious one which leads to many interruptions and fatigue.<br>Human approvals tend to decuple context switching as everybody is asking each other to review pieces of work asynchronously and in parallel.<br>In the best case, people batch review and dedicate time to do so.</p><p>A more efficient way to work is to focus on a <strong>single task at a time,</strong> from definition to completion, and only then move to a new task. It is a well-known principle of lean methodologies and one of the most impactful ways to improve our workflow.</p><h2 id="conclusion-tldr">Conclusion / <code>tl;dr</code></h2><p>Automation and a culture of real-time collaboration, in which everyone assumes the best intentions, can replace the need for human approval in its entirety.</p><p>The best way to convince oneself is to try it out. Experiment for a few months, and measure the results.</p><p>If the results show the opposite, or if the approach does not work in your organisation, you can always go back to human approval, or try different approaches like Trunk Based Development.</p><h2 id="further-inspiration">Further inspiration</h2><ul><li><a href="https://theleanway.net/The-8-Wastes-of-Lean">The 8 Wastes of Lean</a></li><li><a href="https://trunkbaseddevelopment.com/#one-line-summary">Trunk Based Development</a></li><li><a href="https://agilemanifesto.org/">Agile Manifesto</a></li></ul>]]></content:encoded></item><item><title><![CDATA[Ghost: Static Site Generation]]></title><description><![CDATA[<p>For a couple of years now, I have liked <a href="https://ghost.org">Ghost</a> as a way to blog, I first suggested it within my current company as a way to share content about our product-engineering team at <a href="https://tooltime.tech">tooltime.tech</a>.</p><p>What attracted me to it most back then was its writing experience, it is</p>]]></description><link>https://yves.vg/blog/ghost-static-site-generation/</link><guid isPermaLink="false">63e145fedffa61a8d25a6e0a</guid><dc:creator><![CDATA[yvg]]></dc:creator><pubDate>Mon, 06 Feb 2023 19:29:11 GMT</pubDate><content:encoded><![CDATA[<p>For a couple of years now, I have liked <a href="https://ghost.org">Ghost</a> as a way to blog, I first suggested it within my current company as a way to share content about our product-engineering team at <a href="https://tooltime.tech">tooltime.tech</a>.</p><p>What attracted me to it most back then was its writing experience, it is very similar and perhaps superior to the experience of Medium. When I write, I want to focus on content, not on Markdown or HTML syntax.</p><p>For ToolTime, we have chosen to self-host Ghost, however, that did not feel like a good option for a personal blog, it&apos;s rather costly both in terms of money and time to set up and maintain. And for personal usage, I don&apos;t want to think about resources, I don&apos;t want to think about content delivery, availability, databases, etc.</p><p>So I forgot about Ghost and <a href="https://indieweb.social/@yvg/109737589526058311">asked people on Mastodon</a> what they think a blogging setup should look like. Let&apos;s be frank: I wasn&apos;t convinced by any of the answers.</p><p>Eventually, I came back to Ghost, I started wondering if I should simply spend $10 a month for them to care for everything&#x2026; I decided not to, instead, I read through their docs and found weird setups like running Ghost with <em>Gatsby</em> or using <em>11tly</em> as a front-end for a Ghost admin. But what I really wanted was the Ghost writing experience and theming, not a live-running Ghost instance feeding data through a GraphQL API to run Gatsby.</p><h1 id="hooray-npm-community">Hooray npm community</h1><p>That&apos;s when I discovered <code><a href="https://www.npmjs.com/package/ghost-static-site-generator">ghost-static-site-generator</a></code> a tiny command-line tool built in node, seemingly meant to generate a static site from an existing Ghost setup.</p><p>For the folks that don&apos;t use the JS ecosystem much, you&apos;ll first have to install <code><a href="https://docs.npmjs.com/cli/v7/configuring-npm/install">npm</a></code>.&#x200C;&#x200C;</p><p>Then you&apos;ll need to install:</p><ol><li><strong>ghost-cli:</strong> <code>npm install -g ghost-cli@latest</code></li><li>(Optional) <code>wget</code> if your OS doesn&apos;t come with it.</li><li><strong>ghost-static-site-generator:</strong> <code>npm install -g ghost-static-site-generator</code></li></ol><p>From here on, you can now install a local ghost instance, create an empty folder on your machine and run: <code><strong>ghost install local</strong></code>.</p><p>Open the instance in your browser, customise your theme and preferences to your liking, and once you are done. You only need to run: <code><strong>gssg --preview</strong></code>.</p><p>That&apos;s it. What you are seeing now is a statically-served Ghost blog. And a <code>static</code> folder holding the generated content on your disk.</p><p>Given I host this website on Github Pages, all I have to do now is copy the result to my tracked git directory, commit, and push.</p><p>This manual step is something many static-site generators require, which is an acceptable tiny burden to me.</p><hr><p>I hope this is somewhat useful to a couple of curious folks out there.<br>Have a good one!</p><h2 id="tldr">tl;dr:</h2><pre><code class="language-shell">ghost install local 
gssg --url https://yves.vg --subDir &apos;blog&apos;</code></pre>]]></content:encoded></item></channel></rss>